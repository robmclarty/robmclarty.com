---
title: Efficient--Not Perfect--Code
date: 2022-09-01
banner: predator_ridge_banner.jpg
thumbnail: predator_ridge_thumb.jpg
tags:
  - tech
  - process
  - organizing
  - programming
---

Code quality is a balancing act: we can't afford to build *perfect* code because
the benefit doesn't outweight the cost in time to get there. As a business we
want *efficient* code (i.e., organized, concise, simple) and we want to create
code that achieves that goal as *cheaply* as possible (in terms of time and
money). But we also don't want *cheap* code because without enough thought and
effort devoted to orgnanizing it into a consistent and intuitive *pattern* we
will be building up layer upon layer of cruft (tech debt). Patch upon path adds
up to spaghetti. 

We want code that is solid, but not as solid as a diamond (diamonds take a long
time to form). We want it looser than a diamond, but not so loose that it
becomes spaghetti. Something inbetween. Code that is easy to change, easy to
adapt, easy to pivot, is code that is organized, intuitive, and concise enough
to be manipulated (not tightly coupled, not bound to specific test cases, but
also not a mess).
